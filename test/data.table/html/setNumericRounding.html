<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Change or turn off numeric rounding</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for setNumericRounding {data.table}"><tr><td>setNumericRounding {data.table}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Change or turn off numeric rounding </h2>

<h3>Description</h3>

<p>Change rounding to 0, 1 or 2 bytes when joining, grouping or ordering numeric (i.e. double, POSIXct) columns.
</p>


<h3>Usage</h3>

<pre>
setNumericRounding(x)
getNumericRounding()
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> integer or numeric vector: 2 (default), 1 or 0 byte rounding </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computers cannot represent some floating point numbers (such as 0.6) precisely, using base 2. This leads to unexpected behaviour when
joining or grouping columns of type 'numeric'; i.e. 'double', see example below.  To deal with this automatically for convenience, 
when joining or grouping, data.table rounds such data to apx 11 s.f. which is plenty of digits for many cases. This is achieved by
rounding the last 2 bytes off the significand.  Where this is not enough, <code>setNumericRounding</code> can be used to reduce to 1 byte
rounding, or no rounding (0 bytes rounded) for full precision.
</p>
<p>It's bytes rather than bits because it's tied in with the radix sort algorithm for sorting numerics which sorts byte by byte. With the
default rounding of 2 bytes, at most 6 passes are needed. With no rounding, at most 8 passes are needed and hence may be slower. The
choice of default is not for speed however, but to avoid surprising results such as in the example below.
</p>
<p>For large numbers (integers &gt; 2^31), we recommend using <code>bit64::integer64</code> rather than setting rounding to <code>0</code>.
</p>
<p>If you're using <code>POSIXct</code> type column with <em>millisecond</em> (or lower) resolution, you might want to consider setting <code>setNumericRounding(1)</code> . This'll become the default for <code>POSIXct</code> types in the future, instead of the default <code>2</code>.
</p>


<h3>Value</h3>

<p><code>setNumericRounding</code> returns no value; the new value is applied. <code>getNumericRounding</code> returns the current value: 0, 1 or 2.
</p>


<h3>See Also</h3>

<p><a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format">http://en.wikipedia.org/wiki/Double-precision_floating-point_format</a><br />
<a href="http://en.wikipedia.org/wiki/Floating_point">http://en.wikipedia.org/wiki/Floating_point</a><br />
<a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a>
</p>


<h3>Examples</h3>

<pre>
DT = data.table(a=seq(0,1,by=0.2),b=1:2, key="a")
DT
setNumericRounding(0)   # turn off rounding
DT[.(0.4)]   # works
DT[.(0.6)]   # no match, confusing since 0.6 is clearly there in DT

setNumericRounding(2)   # restore default
DT[.(0.6)]   # works as expected

# using type 'numeric' for integers &gt; 2^31 (typically ids)
DT = data.table(id = c(1234567890123, 1234567890124, 1234567890125), val=1:3)
print(DT, digits=15)
DT[,.N,by=id]   # 1 row
setNumericRounding(0)
DT[,.N,by=id]   # 3 rows
# better to use bit64::integer64 for such ids
setNumericRounding(2)
</pre>

<hr /><div style="text-align: center;">[Package <em>data.table</em> version 1.9.6 <a href="00Index.html">Index</a>]</div>
</body></html>
